 scripts/globals/bluemagic.lua               |  48 +++---------
 scripts/globals/combat/magic_hit_rate.lua   |   3 +-
 scripts/globals/job_utils/dragoon.lua       |  10 +--
 scripts/globals/job_utils/rune_fencer.lua   |  20 ++---
 scripts/globals/spells/damage_spell.lua     | 111 ++++++++++++++--------------
 scripts/globals/spells/enfeebling_spell.lua |   3 +-
 scripts/globals/summon.lua                  |   2 +-
 7 files changed, 84 insertions(+), 113 deletions(-)

diff --git a/scripts/globals/bluemagic.lua b/scripts/globals/bluemagic.lua
index a209cafd98..2213fba8db 100644
--- a/scripts/globals/bluemagic.lua
+++ b/scripts/globals/bluemagic.lua
@@ -223,18 +223,10 @@ xi.spells.blue.usePhysicalSpell = function(caster, target, spell, params)
     local hitsdone = 0
     local hitslanded = 0
     local finaldmg = 0
-    local sneakIsApplicable = caster:hasStatusEffect(xi.effect.SNEAK_ATTACK) and
-                                spell:isAoE() == 0 and
-                                params.attackType ~= xi.attackType.RANGED and
-                                (caster:isBehind(target) or caster:hasStatusEffect(xi.effect.HIDE))
-    local trickAttackTarget = (caster:hasStatusEffect(xi.effect.TRICK_ATTACK) and
-                                spell:isAoE() == 0 and
-                                params.attackType ~= xi.attackType.RANGED) and
-                                caster:getTrickAttackChar(target) or nil
 
     while hitsdone < params.numhits do
         local chance = math.random()
-        if sneakIsApplicable or chance <= hitrate then -- it hit
+        if chance <= hitrate then -- it hit
             -- TODO: Check for shadow absorbs. Right now the whole spell will be absorbed by one shadow before it even gets here.
 
             -- Generate a random pDIF between min and max
@@ -242,17 +234,12 @@ xi.spells.blue.usePhysicalSpell = function(caster, target, spell, params)
             pdif = pdif / 1000
 
             -- Add it to our final damage
-            if hitsdone == 0 then -- first hit gets full multiplier
-                if sneakIsApplicable then
-                    finaldmg = finaldmg + (finalD * (multiplier + correlationMultiplier) * (pdif + 0.7))
-                else
-                    finaldmg = finaldmg + (finalD * (multiplier + correlationMultiplier) * pdif)
-                end
+            if hitsdone == 0 then
+                finaldmg = finaldmg + (finalD * (multiplier + correlationMultiplier) * pdif) -- first hit gets full multiplier
             else
                 finaldmg = finaldmg + (finalD * (1 + correlationMultiplier) * pdif)
             end
 
-            sneakIsApplicable = false
             hitslanded = hitslanded + 1
 
             -- increment target's TP (100TP per hit landed)
@@ -261,15 +248,10 @@ xi.spells.blue.usePhysicalSpell = function(caster, target, spell, params)
             end
         end
 
-        if params.attackType ~= xi.attackType.RANGED then
-            caster:delStatusEffect(xi.effect.SNEAK_ATTACK)
-            caster:delStatusEffect(xi.effect.TRICK_ATTACK)
-        end
-
         hitsdone = hitsdone + 1
     end
 
-    return xi.spells.blue.applySpellDamage(caster, target, spell, finaldmg, params, trickAttackTarget)
+    return xi.spells.blue.applySpellDamage(caster, target, spell, finaldmg, params)
 end
 
 -- Get the damage for a magical Blue Magic spell
@@ -307,7 +289,7 @@ xi.spells.blue.useMagicalSpell = function(caster, target, spell, params)
     local finalD = ((initialD + wsc) * (params.multiplier + azureBonus + correlationMultiplier)) + statBonus
 
     -- Multitarget damage reduction
-    local finaldmg = math.floor(finalD * xi.spells.damage.calculateMTDR(caster, target, spell))
+    local finaldmg = math.floor(finalD * xi.spells.damage.calculateMTDR(spell))
 
     -- Resistance
     finaldmg = math.floor(finaldmg * applyResistance(caster, target, spell, params))
@@ -315,7 +297,7 @@ xi.spells.blue.useMagicalSpell = function(caster, target, spell, params)
     -- MAB/MDB/weather/day/affinity/burst effect on damage
     finaldmg = math.floor(addBonuses(caster, spell, target, finaldmg))
 
-    return xi.spells.blue.applySpellDamage(caster, target, spell, finaldmg, params, nil)
+    return xi.spells.blue.applySpellDamage(caster, target, spell, finaldmg, params)
 end
 
 -- Perform a draining magical Blue Magic spell
@@ -342,7 +324,7 @@ xi.spells.blue.useDrainSpell = function(caster, target, spell, params, softCap,
             caster:addMP(dmg)
         else
             dmg = utils.clamp(dmg, 0, target:getHP())
-            dmg = xi.spells.blue.applySpellDamage(caster, target, spell, dmg, params, nil)
+            dmg = xi.spells.blue.applySpellDamage(caster, target, spell, dmg, params)
             caster:addHP(dmg)
         end
     end
@@ -391,13 +373,13 @@ xi.spells.blue.useBreathSpell = function(caster, target, spell, params, isConal)
     -- Final damage
     dmg = target:breathDmgTaken(dmg)
 
-    results[1] = xi.spells.blue.applySpellDamage(caster, target, spell, dmg, params, nil)
+    results[1] = xi.spells.blue.applySpellDamage(caster, target, spell, dmg, params)
     results[2] = resistance
     return results
 end
 
 -- Apply spell damage
-xi.spells.blue.applySpellDamage = function(caster, target, spell, dmg, params, trickAttackTarget)
+xi.spells.blue.applySpellDamage = function(caster, target, spell, dmg, params)
     if dmg < 0 then
         dmg = 0
     end
@@ -408,7 +390,7 @@ xi.spells.blue.applySpellDamage = function(caster, target, spell, dmg, params, t
 
     -- handle MDT, One For All, Liement
     if attackType == xi.attackType.MAGICAL then
-        local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(caster, target, damageType) -- Apply checks for Liement, MDT/MDTII/DT
+        local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(target, damageType) -- Apply checks for Liement, MDT/MDTII/DT
         dmg = math.floor(dmg * targetMagicDamageAdjustment)
         if dmg < 0 then
             target:takeSpellDamage(caster, spell, dmg, attackType, damageType)
@@ -428,15 +410,7 @@ xi.spells.blue.applySpellDamage = function(caster, target, spell, dmg, params, t
     dmg = utils.stoneskin(target, dmg)
 
     target:takeSpellDamage(caster, spell, dmg, attackType, damageType)
-
-    if not target:isPC() then
-        if trickAttackTarget then
-            target:updateEnmityFromDamage(trickAttackTarget, dmg)
-        else
-            target:updateEnmityFromDamage(caster, dmg)
-        end
-    end
-
+    target:updateEnmityFromDamage(caster, dmg)
     target:handleAfflatusMiseryDamage(dmg)
 
     return dmg
diff --git a/scripts/globals/combat/magic_hit_rate.lua b/scripts/globals/combat/magic_hit_rate.lua
index f4baba01c8..cf90184e5c 100644
--- a/scripts/globals/combat/magic_hit_rate.lua
+++ b/scripts/globals/combat/magic_hit_rate.lua
@@ -18,10 +18,9 @@ local elementTable =
 }
 
 -- Actor Magic Accuracy
-xi.combat.magicHitRate.calculateActorMagicAccuracy = function(actor, target, spell, skillType, spellElement, statUsed, bonusMacc)
+xi.combat.magicHitRate.calculateActorMagicAccuracy = function(actor, target, spellGroup, skillType, spellElement, statUsed, bonusMacc)
     local actorJob     = actor:getMainJob()
     local actorWeather = actor:getWeather()
-    local spellGroup   = spell and spell:getSpellGroup() or xi.magic.spellGroup.NONE
     local statDiff     = actor:getStat(statUsed) - target:getStat(statUsed)
     local magicAcc     = actor:getMod(xi.mod.MACC) + actor:getILvlMacc(xi.slot.MAIN)
 
diff --git a/scripts/globals/job_utils/dragoon.lua b/scripts/globals/job_utils/dragoon.lua
index d60380f817..d4f129c4d0 100644
--- a/scripts/globals/job_utils/dragoon.lua
+++ b/scripts/globals/job_utils/dragoon.lua
@@ -709,13 +709,13 @@ xi.job_utils.dragoon.useDamageBreath = function(wyvern, target, skill, action, d
     end
 
     local bonusMacc = strafeMeritPower + master:getMod(xi.mod.WYVERN_BREATH_MACC)
-    local element = damageType - xi.damageType.ELEMENTAL
+    local element   = damageType - xi.damageType.ELEMENTAL
 
     -- "Breath accuracy is directly affected by a wyvern's current HP", but no data exists.
-    local resist              = xi.spells.damage.calculateResist(wyvern, target,  nil, 0, element, 0, bonusMacc)
-    local sdt                 = xi.spells.damage.calculateSDT(wyvern, target, nil, element)
-    local magicBurst          = xi.spells.damage.calculateIfMagicBurst(wyvern, target,  0, element)
-    local nukeAbsorbOrNullify = xi.spells.damage.calculateNukeAbsorbOrNullify(wyvern, target, nil, element)
+    local resist              = xi.spells.damage.calculateResist(wyvern, target, 0, 0, element, 0, bonusMacc)
+    local sdt                 = xi.spells.damage.calculateSDT(target, element)
+    local magicBurst          = xi.spells.damage.calculateIfMagicBurst(target, element)
+    local nukeAbsorbOrNullify = xi.spells.damage.calculateNukeAbsorbOrNullify(target, element)
 
     -- It appears that MB breaths don't do more damage based on testing.
     damage = damage * resist * sdt * nukeAbsorbOrNullify
diff --git a/scripts/globals/job_utils/rune_fencer.lua b/scripts/globals/job_utils/rune_fencer.lua
index 3df525146b..8140d0cbed 100644
--- a/scripts/globals/job_utils/rune_fencer.lua
+++ b/scripts/globals/job_utils/rune_fencer.lua
@@ -492,16 +492,16 @@ end
 local function getSwipeLungeDamageMultipliers(player, target, element, bonusMacc) -- get these multipliers once and store them
     local multipliers = {}
 
-    multipliers.eleStaffBonus       = xi.spells.damage.calculateEleStaffBonus(player, nil, element)
-    multipliers.magianAffinity      = xi.spells.damage.calculateMagianAffinity(player, nil)         -- presumed but untested
-    multipliers.SDT                 = xi.spells.damage.calculateSDT(player, target, nil, element)
-    multipliers.resist              = xi.spells.damage.calculateResist(player, target,  nil, 0, element, 0, bonusMacc)
-    multipliers.magicBurst          = xi.spells.damage.calculateIfMagicBurst(player, target,  0, element)
-    multipliers.magicBurstBonus     = xi.spells.damage.calculateIfMagicBurstBonus(player, target, nil, 0, element)
-    multipliers.dayAndWeather       = xi.spells.damage.calculateDayAndWeather(player, target, nil, 0, element)
-    multipliers.magicBonusDiff      = xi.spells.damage.calculateMagicBonusDiff(player, target, nil, 0, 0, element)
-    multipliers.TMDA                = xi.spells.damage.calculateTMDA(player, target, xi.damageType.ELEMENTAL + element)
-    multipliers.nukeAbsorbOrNullify = xi.spells.damage.calculateNukeAbsorbOrNullify(player, target, nil, element)
+    multipliers.eleStaffBonus       = xi.spells.damage.calculateEleStaffBonus(player, element)
+    multipliers.magianAffinity      = xi.spells.damage.calculateMagianAffinity() -- Presumed but untested.
+    multipliers.SDT                 = xi.spells.damage.calculateSDT(target, element)
+    multipliers.resist              = xi.spells.damage.calculateResist(player, target, 0, 0, element, 0, bonusMacc)
+    multipliers.magicBurst          = xi.spells.damage.calculateIfMagicBurst(target, element)
+    multipliers.magicBurstBonus     = xi.spells.damage.calculateIfMagicBurstBonus(player, target, 0, 0, element)
+    multipliers.dayAndWeather       = xi.spells.damage.calculateDayAndWeather(player, 0, element)
+    multipliers.magicBonusDiff      = xi.spells.damage.calculateMagicBonusDiff(player, target, 0, 0, element)
+    multipliers.TMDA                = xi.spells.damage.calculateTMDA(target, element)
+    multipliers.nukeAbsorbOrNullify = xi.spells.damage.calculateNukeAbsorbOrNullify(target, element)
 
     return multipliers
 end
diff --git a/scripts/globals/spells/damage_spell.lua b/scripts/globals/spells/damage_spell.lua
index 7b1923cb48..f626e2f87e 100644
--- a/scripts/globals/spells/damage_spell.lua
+++ b/scripts/globals/spells/damage_spell.lua
@@ -202,7 +202,7 @@ local pTable =
 -----------------------------------
 -- Basic Functions
 -----------------------------------
-xi.spells.damage.calculateBaseDamage = function(caster, target, spell, spellId, skillType, statUsed)
+xi.spells.damage.calculateBaseDamage = function(caster, target, spellId, skillType, statUsed)
     local spellDamage          = 0 -- The variable we want to calculate
     local baseSpellDamage      = 0 -- (V) In Wiki.
     local baseSpellDamageBonus = 0 -- (mDMG) In Wiki. Get from equipment, status, etc
@@ -314,7 +314,7 @@ xi.spells.damage.calculateBaseDamage = function(caster, target, spell, spellId,
 end
 
 -- Calculate: Multiple Target Damage Reduction (MTDR)
-xi.spells.damage.calculateMTDR = function(caster, target, spell)
+xi.spells.damage.calculateMTDR = function(spell)
     local multipleTargetReduction = 1 -- The variable we want to calculate.
     local targets                 = spell:getTotalTargets()
 
@@ -329,7 +329,7 @@ xi.spells.damage.calculateMTDR = function(caster, target, spell)
     return multipleTargetReduction
 end
 
-xi.spells.damage.calculateEleStaffBonus = function(caster, spell, spellElement)
+xi.spells.damage.calculateEleStaffBonus = function(caster, spellElement)
     local eleStaffBonus = caster:getMod(strongAffinityDmg[spellElement])
 
     if eleStaffBonus > 0 then
@@ -341,7 +341,7 @@ xi.spells.damage.calculateEleStaffBonus = function(caster, spell, spellElement)
     return eleStaffBonus
 end
 
-xi.spells.damage.calculateMagianAffinity = function(caster, spell)
+xi.spells.damage.calculateMagianAffinity = function()
     -- TODO: IMPLEMENT MAGIAN TRIALS AFFINITY SYSTEM, which could be as simple as introducing a new modifier. Out of the scope of this rewrite, for now
     local magianAffinity = 1
 
@@ -352,7 +352,7 @@ xi.spells.damage.calculateMagianAffinity = function(caster, spell)
 end
 
 -- Elemental Specific Damage Taken (Elemental SDT)
-xi.spells.damage.calculateSDT = function(caster, target, spell, spellElement)
+xi.spells.damage.calculateSDT = function(target, spellElement)
     local sdt    = 1 -- The variable we want to calculate
     local sdtMod = 0
 
@@ -382,12 +382,9 @@ end
 
 -- This function is used to calculate Resist tiers. The resist tiers work differently for enfeebles (which usually affect duration, not potency) than for nukes.
 -- This is for nukes damage only. If an spell happens to do both damage and apply an status effect, they are calculated separately.
-xi.spells.damage.calculateResist = function(caster, target, spell, skillType, spellElement, statUsed)
-    -- Get Bonus Magic Accruacy for the spell
-    local bonusMacc = pTable[spell:getID()][bonusSpellMacc]
-
+xi.spells.damage.calculateResist = function(caster, target, spellGroup, skillType, spellElement, statUsed, bonusMacc)
     -- Get Caster Magic Accuracy.
-    local magicAcc = xi.combat.magicHitRate.calculateActorMagicAccuracy(caster, target, spell, skillType, spellElement, statUsed, bonusMacc)
+    local magicAcc = xi.combat.magicHitRate.calculateActorMagicAccuracy(caster, target, spellGroup, skillType, spellElement, statUsed, bonusMacc)
 
     -- Get Target Magic Evasion.
     local magicEva = xi.combat.magicHitRate.calculateTargetMagicEvasion(caster, target, spellElement, false, 0) -- false = not an enfeeble. 0 = No meva modifier.
@@ -401,7 +398,7 @@ xi.spells.damage.calculateResist = function(caster, target, spell, skillType, sp
     return resist
 end
 
-xi.spells.damage.calculateIfMagicBurst = function(caster, target, spell, spellElement)
+xi.spells.damage.calculateIfMagicBurst = function(target, spellElement)
     local magicBurst         = 1 -- The variable we want to calculate
     local _, skillchainCount = FormMagicBurst(spellElement, target) -- External function. Not present in magic.lua.
 
@@ -427,7 +424,7 @@ xi.spells.damage.calculateIfMagicBurst = function(caster, target, spell, spellEl
     return magicBurst
 end
 
-xi.spells.damage.calculateIfMagicBurstBonus = function(caster, target, spell, spellId, spellElement)
+xi.spells.damage.calculateIfMagicBurstBonus = function(caster, target, spellId, spellGroup, spellElement)
     local magicBurstBonus        = 1 -- The variable we want to calculate
     local modBurst               = 1
     local ancientMagicBurstBonus = 0
@@ -442,8 +439,7 @@ xi.spells.damage.calculateIfMagicBurstBonus = function(caster, target, spell, sp
     -- MBB = MBB + trait
 
     if
-        spell and
-        spell:getSpellGroup() == 3 and
+        spellGroup == xi.magic.spellGroup.BLUE and
         not (caster:hasStatusEffect(xi.effect.BURST_AFFINITY) or caster:hasStatusEffect(xi.effect.AZURE_LORE))
     then
         return magicBurstBonus
@@ -476,7 +472,7 @@ xi.spells.damage.calculateIfMagicBurstBonus = function(caster, target, spell, sp
     return magicBurstBonus
 end
 
-xi.spells.damage.calculateDayAndWeather = function(caster, target, spell, spellId, spellElement)
+xi.spells.damage.calculateDayAndWeather = function(caster, spellId, spellElement)
     local dayAndWeather = 1 -- The variable we want to calculate
     local weather       = caster:getWeather()
     local dayElement    = VanadielDayElement()
@@ -539,7 +535,7 @@ xi.spells.damage.calculateDayAndWeather = function(caster, target, spell, spellI
 end
 
 -- Magic Attack Bonus VS Magic Defense Bonus
-xi.spells.damage.calculateMagicBonusDiff = function(caster, target, spell, spellId, skillType, spellElement)
+xi.spells.damage.calculateMagicBonusDiff = function(caster, target, spellId, skillType, spellElement)
     local magicBonusDiff = 1 -- The variable we want to calculate
     local casterJob      = caster:getMainJob()
     local mab            = caster:getMod(xi.mod.MATT)
@@ -627,10 +623,10 @@ end
 -- Calculate: Target Magic Damage Adjustment (TMDA)
 -- SDT follow-up. This time for specific modifiers.
 -- Referred to on item as "Magic Damage Taken -%", "Damage Taken -%" (Ex. Defending Ring) and "Magic Damage Taken II -%" (Aegis)
-xi.spells.damage.calculateTMDA = function(caster, target, damageType)
-    local targetMagicDamageAdjustment = 1 -- The variable we want to calculate
+xi.spells.damage.calculateTMDA = function(target, spellElement)
+    local damageType                  = xi.damageType.ELEMENTAL + spellElement
+    local targetMagicDamageAdjustment = target:checkLiementAbsorb(damageType) -- Check for Liement.
 
-    targetMagicDamageAdjustment = target:checkLiementAbsorb(damageType) -- check for Liement.
     if targetMagicDamageAdjustment < 0 then -- skip MDT/DT/MDTII etc for Liement if we absorb.
         return targetMagicDamageAdjustment
     end
@@ -640,20 +636,20 @@ xi.spells.damage.calculateTMDA = function(caster, target, damageType)
     -- 2500 would mean 25% ADDITIONAL damage taken.
     -- The effects of the "Shell" spells are also included in this step.
 
-    local globalDamageTaken     = target:getMod(xi.mod.DMG) / 10000         -- Mod is base 10000
-    local magicDamageTaken      = target:getMod(xi.mod.DMGMAGIC) / 10000    -- Mod is base 10000
-    local magicDamageTakenII    = target:getMod(xi.mod.DMGMAGIC_II) / 10000 -- Mod is base 10000
-    local uMagicDamageTaken     = target:getMod(xi.mod.UDMGMAGIC) / 10000   -- Mod is base 10000.
+    local globalDamageTaken   = target:getMod(xi.mod.DMG) / 10000         -- Mod is base 10000
+    local magicDamageTaken    = target:getMod(xi.mod.DMGMAGIC) / 10000    -- Mod is base 10000
+    local magicDamageTakenII  = target:getMod(xi.mod.DMGMAGIC_II) / 10000 -- Mod is base 10000
+    local uMagicDamageTaken   = target:getMod(xi.mod.UDMGMAGIC) / 10000   -- Mod is base 10000.
+    local combinedDamageTaken = utils.clamp(magicDamageTaken + globalDamageTaken, -0.5, 0.5) -- The combination of regular "Damage Taken" and "Magic Damage Taken" caps at 50% both ways.
 
-    local combinedDamageTaken   = utils.clamp(magicDamageTaken + globalDamageTaken, -0.5, 0.5) -- The combination of regular "Damage Taken" and "Magic Damage Taken" caps at 50% both ways.
-    targetMagicDamageAdjustment = utils.clamp(1 + combinedDamageTaken + magicDamageTakenII, 0.125, 1.875) -- "Magic Damage Taken II" bypasses the regular cap, but combined cap is 87.5% both ways.
+    targetMagicDamageAdjustment = utils.clamp(targetMagicDamageAdjustment + combinedDamageTaken + magicDamageTakenII, 0.125, 1.875) -- "Magic Damage Taken II" bypasses the regular cap, but combined cap is 87.5% both ways.
     targetMagicDamageAdjustment = utils.clamp(targetMagicDamageAdjustment + uMagicDamageTaken, 0, 2) -- Uncapped magic damage modifier. Cap is 100% both ways.
 
     return targetMagicDamageAdjustment
 end
 
 -- Divine Emblem applies its own damage multiplier.
-xi.spells.damage.calculateDivineEmblemMultiplier = function(caster, target, spell)
+xi.spells.damage.calculateDivineEmblemMultiplier = function(caster)
     local divineEmblemMultiplier = 1
 
     if caster:hasStatusEffect(xi.effect.DIVINE_EMBLEM) then
@@ -665,7 +661,7 @@ xi.spells.damage.calculateDivineEmblemMultiplier = function(caster, target, spel
 end
 
 -- Ebullience applies an entirely separate multiplier.
-xi.spells.damage.calculateEbullienceMultiplier = function(caster, target, spell)
+xi.spells.damage.calculateEbullienceMultiplier = function(caster)
     local ebullienceMultiplier = 1
 
     if caster:hasStatusEffect(xi.effect.EBULLIENCE) then
@@ -677,7 +673,7 @@ xi.spells.damage.calculateEbullienceMultiplier = function(caster, target, spell)
 end
 
 -- CUSTOM function supported in scripts/globals/settings.lua
-xi.spells.damage.calculateSkillTypeMultiplier = function(caster, target, spell, skillType)
+xi.spells.damage.calculateSkillTypeMultiplier = function(skillType)
     local skillTypeMultiplier = 1
 
     if skillType == xi.skill.ELEMENTAL_MAGIC then
@@ -693,7 +689,7 @@ xi.spells.damage.calculateSkillTypeMultiplier = function(caster, target, spell,
     return skillTypeMultiplier
 end
 
-xi.spells.damage.calculateNinSkillBonus = function(caster, target, spell, spellId, skillType)
+xi.spells.damage.calculateNinSkillBonus = function(caster, spellId, skillType)
     local ninSkillBonus = 1
 
     if skillType == xi.skill.NINJUTSU and caster:getMainJob() == xi.job.NIN then
@@ -711,7 +707,7 @@ xi.spells.damage.calculateNinSkillBonus = function(caster, target, spell, spellI
     return ninSkillBonus
 end
 
-xi.spells.damage.calculateNinFutaeBonus = function(caster, target, spell, skillType)
+xi.spells.damage.calculateNinFutaeBonus = function(caster, skillType)
     local ninFutaeBonus = 1
 
     if
@@ -725,7 +721,7 @@ xi.spells.damage.calculateNinFutaeBonus = function(caster, target, spell, skillT
     return ninFutaeBonus
 end
 
-xi.spells.damage.calculateUndeadDivinePenalty = function(caster, target, spell, skillType)
+xi.spells.damage.calculateUndeadDivinePenalty = function(target, skillType)
     local undeadDivinePenalty = 1
 
     if target:isUndead() and skillType == xi.skill.DIVINE_MAGIC then
@@ -748,7 +744,7 @@ xi.spells.damage.calculateScarletDeliriumMultiplier = function(caster)
     return scarletDeliriumMultiplier
 end
 
-xi.spells.damage.calculateNukeAbsorbOrNullify = function(caster, target, spell, spellElement)
+xi.spells.damage.calculateNukeAbsorbOrNullify = function(target, spellElement)
     local nukeAbsorbOrNullify = 1
 
     -- Calculate chance for spell absorption.
@@ -769,7 +765,7 @@ xi.spells.damage.calculateNukeAbsorbOrNullify = function(caster, target, spell,
 end
 
 -- Consecutive Elemental Damage Penalty. Most commonly known as "Nuke Wall".
-xi.spells.damage.calculateNukeWallFactor = function(caster, target, spell, spellElement, finalDamage)
+xi.spells.damage.calculateNukeWallFactor = function(target, spellElement, finalDamage)
     local nukeWallFactor = 1
 
     -- Initial check.
@@ -819,32 +815,33 @@ xi.spells.damage.useDamageSpell = function(caster, target, spell)
     local finalDamage  = 0 -- The variable we want to calculate
 
     -- Get Tabled Variables.
-    local spellId         = spell:getID()
-    local skillType       = spell:getSkillType()
-    local spellElement    = spell:getElement()
-    local statUsed        = pTable[spellId][stat]
-    local spellDamageType = xi.damageType.ELEMENTAL + spellElement
+    local spellId      = spell:getID()
+    local skillType    = spell:getSkillType()
+    local spellGroup   = spell:getSpellGroup()
+    local spellElement = spell:getElement()
+    local statUsed     = pTable[spellId][stat]
+    local bonusMacc    = pTable[spellId][bonusSpellMacc]
 
     -- Variables/steps to calculate finalDamage.
-    local spellDamage                 = xi.spells.damage.calculateBaseDamage(caster, target, spell, spellId, skillType, statUsed)
-    local multipleTargetReduction     = xi.spells.damage.calculateMTDR(caster, target, spell)
-    local eleStaffBonus               = xi.spells.damage.calculateEleStaffBonus(caster, spell, spellElement)
-    local magianAffinity              = xi.spells.damage.calculateMagianAffinity(caster, spell)
-    local sdt                         = xi.spells.damage.calculateSDT(caster, target, spell, spellElement)
-    local resist                      = xi.spells.damage.calculateResist(caster, target, spell, skillType, spellElement, statUsed)
-    local magicBurst                  = xi.spells.damage.calculateIfMagicBurst(caster, target,  spell, spellElement)
-    local magicBurstBonus             = xi.spells.damage.calculateIfMagicBurstBonus(caster, target, spell, spellId, spellElement)
-    local dayAndWeather               = xi.spells.damage.calculateDayAndWeather(caster, target, spell, spellId, spellElement)
-    local magicBonusDiff              = xi.spells.damage.calculateMagicBonusDiff(caster, target, spell, spellId, skillType, spellElement)
-    local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(caster, target, spellDamageType)
-    local divineEmblemMultiplier      = xi.spells.damage.calculateDivineEmblemMultiplier(caster, target, spell)
-    local ebullienceMultiplier        = xi.spells.damage.calculateEbullienceMultiplier(caster, target, spell)
-    local skillTypeMultiplier         = xi.spells.damage.calculateSkillTypeMultiplier(caster, target, spell, skillType)
-    local ninSkillBonus               = xi.spells.damage.calculateNinSkillBonus(caster, target, spell, spellId, skillType)
-    local ninFutaeBonus               = xi.spells.damage.calculateNinFutaeBonus(caster, target, spell, skillType)
-    local undeadDivinePenalty         = xi.spells.damage.calculateUndeadDivinePenalty(caster, target, spell, skillType)
+    local spellDamage                 = xi.spells.damage.calculateBaseDamage(caster, target, spellId, skillType, statUsed)
+    local multipleTargetReduction     = xi.spells.damage.calculateMTDR(spell)
+    local eleStaffBonus               = xi.spells.damage.calculateEleStaffBonus(caster, spellElement)
+    local magianAffinity              = xi.spells.damage.calculateMagianAffinity()
+    local sdt                         = xi.spells.damage.calculateSDT(target, spellElement)
+    local resist                      = xi.spells.damage.calculateResist(caster, target, spellGroup, skillType, spellElement, statUsed, bonusMacc)
+    local magicBurst                  = xi.spells.damage.calculateIfMagicBurst(target, spellElement)
+    local magicBurstBonus             = xi.spells.damage.calculateIfMagicBurstBonus(caster, target, spellId, spellGroup, spellElement)
+    local dayAndWeather               = xi.spells.damage.calculateDayAndWeather(caster, spellId, spellElement)
+    local magicBonusDiff              = xi.spells.damage.calculateMagicBonusDiff(caster, target, spellId, skillType, spellElement)
+    local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(target, spellElement)
+    local divineEmblemMultiplier      = xi.spells.damage.calculateDivineEmblemMultiplier(caster)
+    local ebullienceMultiplier        = xi.spells.damage.calculateEbullienceMultiplier(caster)
+    local skillTypeMultiplier         = xi.spells.damage.calculateSkillTypeMultiplier(skillType)
+    local ninSkillBonus               = xi.spells.damage.calculateNinSkillBonus(caster, spellId, skillType)
+    local ninFutaeBonus               = xi.spells.damage.calculateNinFutaeBonus(caster, skillType)
+    local undeadDivinePenalty         = xi.spells.damage.calculateUndeadDivinePenalty(target, skillType)
     local scarletDeliriumMultiplier   = xi.spells.damage.calculateScarletDeliriumMultiplier(caster)
-    local nukeAbsorbOrNullify         = xi.spells.damage.calculateNukeAbsorbOrNullify(caster, target, spell, spellElement)
+    local nukeAbsorbOrNullify         = xi.spells.damage.calculateNukeAbsorbOrNullify(target, spellElement)
 
     -- Calculate finalDamage. It MUST be floored after EACH multiplication.
     finalDamage = math.floor(spellDamage * multipleTargetReduction)
@@ -867,7 +864,7 @@ xi.spells.damage.useDamageSpell = function(caster, target, spell)
     finalDamage = math.floor(finalDamage * nukeAbsorbOrNullify)
 
     -- Handle "Nuke Wall". It must be handled after all previous calculations, but before clamp.
-    local nukeWallFactor = xi.spells.damage.calculateNukeWallFactor(caster, target, spell, spellElement, finalDamage)
+    local nukeWallFactor = xi.spells.damage.calculateNukeWallFactor(target, spellElement, finalDamage)
 
     finalDamage = math.floor(finalDamage * nukeWallFactor)
 
diff --git a/scripts/globals/spells/enfeebling_spell.lua b/scripts/globals/spells/enfeebling_spell.lua
index 551317276b..fd00c6e1e0 100644
--- a/scripts/globals/spells/enfeebling_spell.lua
+++ b/scripts/globals/spells/enfeebling_spell.lua
@@ -369,6 +369,7 @@ xi.spells.enfeebling.useEnfeeblingSpell = function(caster, target, spell)
     ------------------------------
     local skillType    = spell:getSkillType()
     local spellElement = spell:getElement()
+    local spellGroup   = spell:getSpellGroup()
     local statUsed     = pTable[spellId][2]
     local mEvaMod      = pTable[spellId][4]
     local resistStages = pTable[spellId][8]
@@ -376,7 +377,7 @@ xi.spells.enfeebling.useEnfeeblingSpell = function(caster, target, spell)
     local bonusMacc    = pTable[spellId][13]
 
     -- Magic Hit Rate calculations.
-    local magicAcc     = xi.combat.magicHitRate.calculateActorMagicAccuracy(caster, target, spell, skillType, spellElement, statUsed, bonusMacc)
+    local magicAcc     = xi.combat.magicHitRate.calculateActorMagicAccuracy(caster, target, spellGroup, skillType, spellElement, statUsed, bonusMacc)
     local magicEva     = xi.combat.magicHitRate.calculateTargetMagicEvasion(caster, target, spellElement, true, mEvaMod)
     local magicHitRate = xi.combat.magicHitRate.calculateMagicHitRate(magicAcc, magicEva)
 
diff --git a/scripts/globals/summon.lua b/scripts/globals/summon.lua
index 8ad70431fa..34add47673 100644
--- a/scripts/globals/summon.lua
+++ b/scripts/globals/summon.lua
@@ -383,7 +383,7 @@ xi.summon.avatarFinalAdjustments = function(dmg, mob, skill, target, skilltype,
 
     -- handle One For All, Liement
     if skilltype == xi.attackType.MAGICAL then
-        local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(mob, target, damagetype) -- Apply checks for Liement, MDT/MDTII/DT
+        local targetMagicDamageAdjustment = xi.spells.damage.calculateTMDA(target, damagetype) -- Apply checks for Liement, MDT/MDTII/DT
 
         dmg = math.floor(dmg * targetMagicDamageAdjustment)
         if dmg < 0 then
